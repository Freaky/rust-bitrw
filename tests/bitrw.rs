extern crate bitrw;
extern crate rand;

use rand::Rng;
use std::io::Cursor;

const MASKS: [u64; 65] = [
    0,
    0b1,
    0b11,
    0b111,
    0b1111,
    0b11111,
    0b111111,
    0b1111111,
    0b11111111,
    0b111111111,
    0b1111111111,
    0b11111111111,
    0b111111111111,
    0b1111111111111,
    0b11111111111111,
    0b111111111111111,
    0b1111111111111111,
    0b11111111111111111,
    0b111111111111111111,
    0b1111111111111111111,
    0b11111111111111111111,
    0b111111111111111111111,
    0b1111111111111111111111,
    0b11111111111111111111111,
    0b111111111111111111111111,
    0b1111111111111111111111111,
    0b11111111111111111111111111,
    0b111111111111111111111111111,
    0b1111111111111111111111111111,
    0b11111111111111111111111111111,
    0b111111111111111111111111111111,
    0b1111111111111111111111111111111,
    0b11111111111111111111111111111111,
    0b111111111111111111111111111111111,
    0b1111111111111111111111111111111111,
    0b11111111111111111111111111111111111,
    0b111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111111111111111111111111,
    0b11111111111111111111111111111111111111111111111111111111111111,
    0b111111111111111111111111111111111111111111111111111111111111111,
    0b1111111111111111111111111111111111111111111111111111111111111111,
];

use bitrw::{BitReader, BitWriter};

struct TestBitIO {
    nbits: u8,
    value: u64,
}

fn test_ios(ios: Vec<TestBitIO>) {
    let buf: Vec<u8> = vec![];

    let mut writer = BitWriter::new(buf);

    for io in &ios {
        assert_eq!(
            writer.write_bits(io.nbits, io.value).unwrap(),
            io.nbits as usize
        );
    }

    let sum: usize = ios.iter().map(|x| x.nbits as usize).sum();
    let remain = 8 - (sum % 8);
    let remain = if remain == 8 { 0 } else { remain };

    assert_eq!(writer.flush().unwrap(), remain);

    let rbuf = Cursor::new(writer.into_inner());

    let mut reader = BitReader::new(rbuf);
    for io in &ios {
        assert_eq!(
            reader.read_bits(io.nbits).unwrap(),
            io.value & MASKS[io.nbits as usize]
        );
    }
}

#[test]
fn random_testing() {
    let mut rng = rand::thread_rng();

    for len in 1..128 {
        for _ in 1..128 {
            let mut ios: Vec<TestBitIO> = Vec::with_capacity(len);

            for _ in 0..len {
                ios.push(TestBitIO {
                    nbits: rng.gen::<u8>() % 64,
                    value: rng.gen::<u64>(),
                });
            }

            test_ios(ios);
        }
    }
}
